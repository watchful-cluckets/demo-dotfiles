{
  "Python Load Local Eng": {
    "prefix": "pyloadenv",
    "body": [
      "# load local env vars",
      "project_folder = os.path.expanduser('.')",
      "load_dotenv(os.path.join(project_folder, '.env'))"
    ],
    "description": "Python Load Local Eng"
  },
  "Python Script Stub": {
    "prefix": "pyscript",
    "body": [
      "\"\"\"",
      "A template script",
      "\"\"\"",
      "",
      "import argparse",
      "import datetime as dt",
      "import logging",
      "import os",
      "import sys",
      "import time",
      "",
      "class CustomFormatter(logging.Formatter):",
      "    \"\"\"Logging Formatter to add colors and count warning / errors\"\"\"",
      "",
      "    grey = \"\\x1b[38;21m\"",
      "    yellow = \"\\x1b[33;21m\"",
      "    red = \"\\x1b[31;21m\"",
      "    bold_red = \"\\x1b[31;1m\"",
      "    reset = \"\\x1b[0m\"",
      "    format = \"%(asctime)s - %(name)s - %(levelname)8s - %(message)s (%(filename)s:%(lineno)d)\"",
      "",
      "    FORMATS = {",
      "        logging.DEBUG: grey + format + reset,",
      "        logging.INFO: grey + format + reset,",
      "        logging.WARNING: yellow + format + reset,",
      "        logging.ERROR: red + format + reset,",
      "        logging.CRITICAL: bold_red + format + reset",
      "    }",
      "",
      "    def format(self, record):",
      "        \"\"\"",
      "        Format a log message with color",
      "",
      "        :param record: a log msg",
      "        :type record: LogRecord",
      "        :return: a colorized log msg",
      "        :rtype: LogRecord",
      "        \"\"\"",
      "        log_fmt = self.FORMATS.get(record.levelno)",
      "        formatter = logging.Formatter(log_fmt)",
      "        return formatter.format(record)",
      "",
      "",
      "# setup file logger",
      "start_time = time.time()",
      "logfile = os.path.splitext(os.path.basename(__file__))[0] + '.log'",
      "dtefmt = '%d-%m-%Y %H:%M:%S'",
      "logging.basicConfig(level=logging.DEBUG,",
      "                    datefmt=dtefmt,",
      "                    filename=logfile,",
      "                    filemode='w')",
      "prog_name = os.path.splitext(os.path.basename(__file__))[0]",
      "log = logging.getLogger(prog_name)",
      "log.setLevel(logging.DEBUG)",
      "console = logging.StreamHandler()",
      "console.setLevel(logging.INFO)",
      "console.setFormatter(CustomFormatter())",
      "log.addHandler(console)",
      "",
      "",
      "class FullPaths(argparse.Action):",
      "    \"\"\"",
      "    A class to represent the full path of an object",
      "",
      "    \"\"\"",
      "    def __call__(self, parser, namespace, values, option_string=None):",
      "        \"\"\"",
      "        A function to expand user- and relative-paths",
      "        :param parser:",
      "        :param namespace:",
      "        :param values:",
      "        :param option_string:",
      "        \"\"\"",
      "        setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))",
      "",
      "",
      "def time_now():",
      "    \"\"\"",
      "    Returns the current system time in UTC RFC3339 ISO format.",
      "",
      "    :return: current time in UTC RFC3339 ISO format",
      "    :rtype: datetime object",
      "    \"\"\"",
      "    return dt.datetime.utcnow().replace(tzinfo=dt.timezone.utc).isoformat()",
      "",
      "",
      "def is_dir(dirname):",
      "    \"\"\"",
      "    Checks if a path is an actual directory",
      "    :param dirname: a directory name",
      "    :return: the directory name",
      "    \"\"\"",
      "    if not os.path.isdir(dirname):",
      "        msg = \"{0} is not a directory\".format(dirname)",
      "        raise argparse.ArgumentTypeError(msg)",
      "    else:",
      "        return dirname",
      "",
      "",
      "def parse_arguments():",
      "    \"\"\"",
      "    Parses arguments from command line",
      "    :return: array of parsed arguments",
      "    \"\"\"",
      "    parser = argparse.ArgumentParser(",
      "        description=\"Brief description of program\",",
      "        formatter_class=argparse.ArgumentDefaultsHelpFormatter",
      "    )",
      "    parser.add_argument(\"-d\", \"--datadir\", type=is_dir, help=\"data directory\",",
      "                        action=FullPaths, required=False)",
      "    parser.add_argument(\"-s\", \"--service\", help=\"service to query\", required=True)",
      "    parser.add_argument(\"-v\", \"--verbose\", help=\"increase verbosity\",",
      "                        action=\"store_true\")",
      "    parser.add_argument(\"-a1\", \"--arg1\", type=int, default=0, help=\"First argument!\")",
      "    parser.add_argument(\"-a2\", \"--arg2\", type=str, default=\"HeHe\",",
      "                        help=\"Second argument!\")",
      "    args = parser.parse_args()",
      "    return args",
      "",
      "",
      "def main():",
      "    \"\"\"",
      "    The main program that ___",
      "    :rtype: object",
      "    \"\"\"",
      "    # parse arguments",
      "    args = parse_arguments()",
      "",
      "    # set verbosity",
      "    if args.verbose:",
      "        log.setLevel(logging.DEBUG)",
      "",
      "    # the program",
      "    # <do stuff>",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    log.info(\"#### run-start: {}\".format(time_now()))",
      "    main()",
      "    log.info(\"#### run-end: {}\".format(time_now()))",
      "    log.info(\"#### run-elapsed: {}\".format(time.time() - start_time))",
      "    sys.exit()",
      ""
    ],
    "description": "Python Script Stub"
  },
  "Python Suppress Stdout/Stderr": {
    "prefix": "py-suppress",
    "body": [
      "class SuppressStdout(object):",
      "    \"\"\"",
      "    https://github.com/facebook/prophet/issues/223#issuecomment-326455744",
      "    A context manager for doing a \"deep suppression\" of stdout and stderr in",
      "    Python, i.e. will suppress all print, even if the print originates in a",
      "    compiled C/Fortran sub-function.",
      "",
      "    This will not suppress raised exceptions, since exceptions are printed",
      "    to stderr just before a script exits, and after the context manager has",
      "    exited (at least, I think that is why it lets exceptions through).",
      "    \"\"\"",
      "",
      "    def __init__(self):",
      "        # Open a pair of null files",
      "        self.null_fds = [os.open(os.devnull, os.O_RDWR) for x in range(2)]",
      "        # Save the actual stdout (1) and stderr (2) file descriptors.",
      "        self.save_fds = [os.dup(1), os.dup(2)]",
      "",
      "    def __enter__(self):",
      "        # Assign the null pointers to stdout and stderr.",
      "        os.dup2(self.null_fds[0], 1)",
      "        os.dup2(self.null_fds[1], 2)",
      "",
      "    def __exit__(self, *_):",
      "        # Re-assign the real stdout/stderr back to (1) and (2)",
      "        os.dup2(self.save_fds[0], 1)",
      "        os.dup2(self.save_fds[1], 2)",
      "        # Close the null files",
      "        for fd in self.null_fds + self.save_fds:",
      "            os.close(fd)",
      "",
      "with self.suppress_stdout_stderr():",
      "    do_something_noisy(yeah)"
    ],
    "description": "Python Suppress Stdout/Stderr"
  },
  "Python Read JSON file": {
    "prefix": "read-json",
    "body": [
      "infile = \"a.json\"",
      "with open(infile, 'r') as f:",
      "    json_lines = json.load(f)"
    ],
    "description": "Open JSON file"
  },
  "Python Write JSON file": {
    "prefix": "write-json",
    "body": [
      "outfile = \"b.json\"",
      "with open(outfile, 'w') as f:",
      "    json.dump(json_lines, f, indent=4)"
    ],
    "description": "Write JSON file"
  },
  "Python Call an API endpoint": {
    "prefix": "api-call",
    "body": [
      "url = 'https://a-url/endpoint/{}+{}'",
      "apikey = os.getenv(\"APIKEY\")",
      "try:",
      "    response = requests.request('GET', url)",
      "    if response.status_code != 200:",
      "        logging.error('Err status code: {}'.format(response.status_code))",
      "        sys.exit(1)",
      "    else:",
      "        data = response.json()",
      "        print(data)",
      "except Exception as e:",
      "    logging.exception(e)",
      "    logging.exception(traceback.format_exc())",
      "    sys.exit(1)"
    ],
    "description": "Call an API endpoint"
  },
  "Python Standard imports": {
    "prefix": "pyimport",
    "body": ["import os ", "import sys", "import logging", "import traceback"],
    "description": "Standard imports"
  },
  "Python Glob files": {
    "prefix": "py-glob",
    "body": [
      "from pathlib import Path",
      "for path in Path('src/dir').rglob('*.extension'):",
      "    print(path.name)"
    ],
    "description": "Python Glob files"
  },
  "Python Read File": {
    "prefix": "py-readfile",
    "body": [
      "with open(filename, 'r') as f:",
      "  for line in f:",
      "    print(line)"
    ],
    "description": "Read file line by line"
  },
  "Python Decorator": {
	"prefix": "pydecorate",
	"body": [
	  "import functools",
	  "",
	  "def decorator(func):",
	  "    @functools.wraps(func)",
	  "    def wrapper_decorator(*args, **kwargs):",
	  "        # Do something before",
	  "        value = func(*args, **kwargs)",
	  "        # Do something after",
	  "        return value",
	  "    return wrapper_decorator"
	],
	"description": "decorator"
  }
}
